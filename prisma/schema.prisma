// prisma/schema.prisma
// ✅ Org-to-Org (Mahajan to Mahajan) version
// Source Mahajan (collector) -> Destination Mahajan (city/distributor)
// Includes: Load Card, Receive Card, Chat with Ledger, Driver Profile, GST badge, map tracking.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  MAHAJAN_OWNER
  MAHAJAN_STAFF
  DRIVER
}

enum OrgMemberRole {
  OWNER
  STAFF
}

enum MahajanRoleType {
  SOURCE_COLLECTOR
  DESTINATION_DISTRIBUTOR
  BOTH
}

enum TripStatus {
  CREATED
  ASSIGNED
  LOADED
  IN_TRANSIT
  ARRIVED
  REACHED
  DELIVERED
  COMPLETED
  CLOSED
  CANCELLED
  DISPUTED
}

enum TripEventType {
  TRIP_CREATED
  ASSIGNED
  LOAD_COMPLETED
  IN_TRANSIT
  ARRIVED
  DELIVERED
  TRIP_COMPLETED
  POD_UPLOADED
  PAYMENT_RECORDED
  DISPUTE_RAISED
  DISPUTE_RESOLVED
  TRIP_CANCELLED
  CLOSED
  NOTE
}

enum QuantityUnit {
  KG
  BAG
  TON
  CRATE
  BOX
  OTHER
}

enum PaymentTag {
  ADVANCE
  PARTIAL
  FINAL
  DUE
  OTHER
}

enum AttachmentType {
  LOAD_PHOTO
  RECEIVE_PHOTO
  INVOICE
  RECEIPT
  OTHER
}

enum LedgerDirection {
  // Convention:
  // PAYABLE = this org owes the counterparty
  // RECEIVABLE = this org should receive from the counterparty
  PAYABLE
  RECEIVABLE
}

model Org {
  // ✅ Every Mahajan is an Org
  id        String          @id @default(cuid())
  name      String
  city      String?
  phone     String?
  address   String?

  // optional GST badge in chat header
  gstin     String?         @unique

  // helps UI label: Source collector / Destination distributor
  roleType  MahajanRoleType @default(BOTH)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members   OrgMember[]
  trucks    Truck[]
  drivers   DriverProfile[]

  // trips where org is source/destination
  sourceTrips      Trip[] @relation("SourceOrgTrips")
  destinationTrips Trip[] @relation("DestinationOrgTrips")

  // ledger accounts
  accountsAsOwner        Account[] @relation("AccountOwnerOrg")
  accountsAsCounterparty Account[] @relation("AccountCounterpartyOrg")

  // chat threads (ledger/trip)
  chatThreads ChatThread[]
}

model User {
  id        String   @id @default(cuid())
  role      UserRole
  name      String
  phone     String   @unique
  passwordHash String

  // ✅ SECURITY FIX: Add account status for suspension/ban functionality
  status       String   @default("ACTIVE") // ACTIVE, SUSPENDED, BANNED
  suspendedAt  DateTime?
  bannedAt     DateTime?
  statusReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships   OrgMember[]
  driverProfile DriverProfile?
  sentMessages  ChatMessage[] @relation("SentMessages")
  typingIndicators TypingIndicator[] @relation("TypingUsers")

  createdLoadCards    TripLoadCard[]
  createdReceiveCards TripReceiveCard[] @relation("CreatedReceiveCards")
  approvedReceiveCards TripReceiveCard[] @relation("ApprovedReceiveCards")
  createdEvents       TripEvent[]

  @@index([status])
}

model OrgMember {
  id        String        @id @default(cuid())
  orgId     String
  org       Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)

  userId    String
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  role      OrgMemberRole @default(STAFF)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, userId])
  // ✅ PERFORMANCE FIX: Add indexes for common query patterns
  @@index([userId])
  @@index([orgId, role])
  @@index([userId, role])
}

model DriverProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // which org primarily manages this driver (optional)
  orgId     String?
  org       Org?     @relation(fields: [orgId], references: [id], onDelete: SetNull)

  licenseNo String?
  emergencyPhone String?
  notes          String?
  deviceId       String?  @unique // For device binding

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  trips     Trip[]   @relation("DriverTrips")
  locations TripLocation[]
}

model Truck {
  id        String   @id @default(cuid())
  orgId     String
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)

  number    String
  type      String?
  capacity  Decimal? @db.Decimal(10, 2) // in tons

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  trips     Trip[]

  @@unique([orgId, number])
}

model Trip {
  id        String   @id @default(cuid())

  // ✅ BOTH sides are mahajans
  sourceOrgId      String
  sourceOrg        Org      @relation("SourceOrgTrips", fields: [sourceOrgId], references: [id], onDelete: Restrict)

  destinationOrgId String
  destinationOrg   Org      @relation("DestinationOrgTrips", fields: [destinationOrgId], references: [id], onDelete: Restrict)

  // truck belongs to the source org (usually); but we keep only truckId
  truckId   String
  truck     Truck    @relation(fields: [truckId], references: [id], onDelete: Restrict)

  driverId  String?
  driver    DriverProfile? @relation("DriverTrips", fields: [driverId], references: [id], onDelete: SetNull)

  startPoint         String?
  endPoint           String?
  startTime          DateTime?
  eta                DateTime?
  estimatedDistance   Float?
  estimatedArrival   DateTime?
  notes              String?

  status    TripStatus @default(CREATED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // map tracking
  locations TripLocation[]
  latestLoc TripLatestLocation?

  // proof + disputes + timeline
  loadCard    TripLoadCard?
  receiveCard TripReceiveCard?
  events      TripEvent[]
  disputes    Dispute[]

  // money + chat
  invoices     Invoice[]
  payments     Payment[]
  ledgerEntries LedgerEntry[]
  chatThreads  ChatThread[]

  // ✅ PERFORMANCE FIX: Add composite indexes for active trip lookups
  @@index([sourceOrgId, status, createdAt])
  @@index([destinationOrgId, status, createdAt])
  @@index([truckId, createdAt])
  @@index([driverId, createdAt])
  @@index([driverId, status])
  @@index([truckId, status])
}

model TripLoadCard {
  id       String   @id @default(cuid())
  tripId   String   @unique
  trip     Trip     @relation(fields: [tripId], references: [id], onDelete: Cascade)

  quantity Decimal  @db.Decimal(12, 3)
  unit     QuantityUnit
  loadedAt DateTime @default(now())
  remarks  String?

  createdByUserId String?
  createdByUser   User?   @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  attachments Attachment[]

  @@index([loadedAt])
}

model TripReceiveCard {
  id        String   @id @default(cuid())
  tripId    String   @unique
  trip      Trip     @relation(fields: [tripId], references: [id], onDelete: Cascade)

  quantity  Decimal  @db.Decimal(12, 3)
  unit      QuantityUnit
  receivedAt DateTime @default(now())
  shortage   Decimal? @db.Decimal(12, 3) // Auto-calculated: loaded - received
  remarks    String?

  // ✅ BUSINESS LOGIC FIX: Add approval workflow to prevent unilateral shortage claims
  status           String  @default("PENDING") // PENDING, APPROVED, DISPUTED
  approvedAt       DateTime?
  approvedByUserId String?
  approvedByUser   User?   @relation("ApprovedReceiveCards", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  disputeReason    String?

  createdByUserId String?
  createdByUser   User?   @relation("CreatedReceiveCards", fields: [createdByUserId], references: [id], onDelete: SetNull)

  attachments Attachment[]

  @@index([receivedAt])
  @@index([status])
}

model TripEvent {
  id        String       @id @default(cuid())
  tripId    String
  trip      Trip         @relation(fields: [tripId], references: [id], onDelete: Cascade)

  eventType TripEventType
  description String?
  metaJson  Json?
  atTime    DateTime     @default(now())

  createdByUserId String?
  createdByUser   User?   @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([tripId, atTime])
  @@index([eventType, atTime])
}

model TripLocation {
  id         String   @id @default(cuid())
  tripId     String
  trip       Trip     @relation(fields: [tripId], references: [id], onDelete: Cascade)

  driverId   String?
  driver     DriverProfile? @relation(fields: [driverId], references: [id], onDelete: SetNull)

  lat        Float
  lng        Float
  speed      Float?
  heading    Float?
  accuracy   Float?
  batchId    String?  // For idempotency
  capturedAt DateTime
  createdAt  DateTime @default(now())

  @@index([tripId, capturedAt])
  @@index([driverId, capturedAt])
  @@index([batchId])
}

model TripLatestLocation {
  tripId     String   @id
  trip       Trip     @relation(fields: [tripId], references: [id], onDelete: Cascade)

  lat        Float
  lng        Float
  speed      Float?
  heading    Float?
  accuracy   Float?
  capturedAt DateTime
  updatedAt  DateTime @updatedAt
}

model Account {
  // ✅ "Khata" between two Mahajans (Org <-> Org)
  id        String @id @default(cuid())

  // the org that is viewing/owning this account record
  ownerOrgId String
  ownerOrg   Org    @relation("AccountOwnerOrg", fields: [ownerOrgId], references: [id], onDelete: Cascade)

  // the other mahajan
  counterpartyOrgId String
  counterpartyOrg   Org    @relation("AccountCounterpartyOrg", fields: [counterpartyOrgId], references: [id], onDelete: Restrict)

  // Running balance (can be calculated from entries, but cached here for performance)
  balance   BigInt @default(0) // paise

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entries   LedgerEntry[]
  invoices  Invoice[]
  payments  Payment[]
  threads   ChatThread[]

  @@unique([ownerOrgId, counterpartyOrgId])
  @@index([ownerOrgId])
  @@index([counterpartyOrgId])
}

model LedgerEntry {
  id         String @id @default(cuid())

  accountId  String
  account    Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  tripId     String?
  trip       Trip?   @relation(fields: [tripId], references: [id], onDelete: SetNull)

  direction  LedgerDirection
  amount     BigInt // paise
  balance    BigInt // Running balance after this entry
  description String?
  note       String?
  tag        PaymentTag?

  referenceType String? // "INVOICE" | "PAYMENT" | "TRIP"
  referenceId   String?

  createdAt  DateTime @default(now())

  chatMessages ChatMessage[]

  @@index([accountId, createdAt])
  @@index([tripId])
}

model Invoice {
  id        String @id @default(cuid())

  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Restrict)

  tripId    String?
  trip      Trip?   @relation(fields: [tripId], references: [id], onDelete: SetNull)

  invoiceNumber String  // ✅ BUSINESS LOGIC FIX: Removed @unique - invoice numbers are org-specific, not global
  total     BigInt  // paise
  dueDate   DateTime?
  status    String  @default("OPEN") // OPEN, PARTIAL, PAID, CANCELLED
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments    Payment[]
  attachments Attachment[]
  chatMessages ChatMessage[]

  // ✅ BUSINESS LOGIC FIX: Invoice numbers unique per account (Mahajan A's INV-001 ≠ Mahajan B's INV-001)
  @@unique([accountId, invoiceNumber])
  @@index([accountId, status])
  @@index([dueDate])
}

model Payment {
  id        String @id @default(cuid())

  accountId String?
  account   Account? @relation(fields: [accountId], references: [id], onDelete: SetNull)

  invoiceId String?
  invoice   Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  tripId    String?
  trip      Trip?    @relation(fields: [tripId], references: [id], onDelete: SetNull)

  amount    BigInt   // paise
  paidAt    DateTime @default(now())
  mode      String?  // CASH, UPI, BANK_TRANSFER, CHEQUE
  reference String?  // Transaction ID
  tag       PaymentTag?
  remarks   String?

  attachments Attachment[]
  chatMessages ChatMessage[]

  createdAt DateTime @default(now())

  @@index([accountId, paidAt])
  @@index([invoiceId, paidAt])
  @@index([tripId, paidAt])
}

model Dispute {
  id        String @id @default(cuid())
  tripId    String
  trip      Trip    @relation(fields: [tripId], references: [id], onDelete: Cascade)

  reason    String
  status    String @default("OPEN") // OPEN, RESOLVED, REJECTED
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
}

model ChatThread {
  id        String @id @default(cuid())

  // thread belongs to a mahajan org (who is using the app)
  orgId     String
  org       Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // optionally tied to a counterparty account (ledger chat)
  accountId String?
  account   Account? @relation(fields: [accountId], references: [id], onDelete: SetNull)

  // optionally tied to a specific trip (trip chat)
  tripId    String?
  trip      Trip?   @relation(fields: [tripId], references: [id], onDelete: SetNull)

  title     String?
  type      String  @default("GENERAL") // LEDGER_CHAT, TRIP_CHAT, GENERAL

  // ✅ WhatsApp-like features
  lastMessageAt    DateTime?
  lastMessageText  String?
  unreadCount      Int @default(0)
  isArchived       Boolean @default(false)
  isPinned         Boolean @default(false)
  pinnedAt         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages  ChatMessage[]
  typingIndicators TypingIndicator[]

  // ✅ CRITICAL FIX: Prevent duplicate threads for same account/trip
  @@unique([accountId])
  @@unique([tripId])
  @@index([orgId, updatedAt])
  @@index([orgId, lastMessageAt])
  @@index([orgId, isPinned, lastMessageAt])
  @@index([accountId, updatedAt])
  @@index([tripId, updatedAt])
}

// ✅ Real-time typing indicators like WhatsApp
model TypingIndicator {
  id        String @id @default(cuid())

  threadId  String
  thread    ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  userId    String
  user      User @relation("TypingUsers", fields: [userId], references: [id], onDelete: Cascade)
  isTyping  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([threadId, userId])
  @@index([threadId, isTyping, updatedAt])
}

model ChatMessage {
  id        String @id @default(cuid())

  threadId  String
  thread    ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  senderUserId String?
  senderUser   User? @relation("SentMessages", fields: [senderUserId], references: [id], onDelete: SetNull)

  content   String?
  messageType String @default("TEXT") // TEXT, PAYMENT_NOTIFICATION, INVOICE_NOTIFICATION, SYSTEM_MESSAGE, LOCATION_SHARE, IMAGE, VOICE, DOCUMENT
  tag       PaymentTag?

  // make chat transaction-aware
  paymentId     String?
  payment       Payment?     @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  invoiceId     String?
  invoice       Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  ledgerEntryId String?
  ledgerEntry   LedgerEntry? @relation(fields: [ledgerEntryId], references: [id], onDelete: SetNull)

  // ✅ WhatsApp-like features
  isRead        Boolean @default(false)
  readAt        DateTime?
  isDelivered   Boolean @default(false)
  deliveredAt   DateTime?
  isEdited      Boolean @default(false)
  editedAt      DateTime?
  replyToId     String?
  replyTo       ChatMessage? @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies       ChatMessage[] @relation("MessageReplies")

  // For location sharing (lat, lng from tracking)
  locationLat   Float?
  locationLng   Float?

  attachments Attachment[]

  createdAt DateTime @default(now())

  // ✅ PERFORMANCE FIX: Optimize indexes for common query patterns
  @@index([threadId, createdAt])
  @@index([paymentId])
  @@index([invoiceId])
  @@index([senderUserId, createdAt])
  @@index([threadId, isRead, senderUserId])
  @@index([threadId, senderUserId, isRead])
}

model Attachment {
  id        String         @id @default(cuid())
  type      AttachmentType @default(OTHER)

  url       String
  s3Key     String?  @unique
  mimeType  String?
  fileName  String?
  sizeBytes Int?
  status    String   @default("PENDING") // PENDING, COMPLETED, FAILED

  uploadedBy String? // userId

  createdAt DateTime @default(now())

  loadCardId    String?
  loadCard      TripLoadCard?   @relation(fields: [loadCardId], references: [id], onDelete: Cascade)

  receiveCardId String?
  receiveCard   TripReceiveCard? @relation(fields: [receiveCardId], references: [id], onDelete: Cascade)

  invoiceId     String?
  invoice       Invoice?        @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  paymentId     String?
  payment       Payment?        @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  messageId     String?
  message       ChatMessage?    @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([type, createdAt])
  @@index([status])
  @@index([invoiceId])
  @@index([paymentId])
  @@index([messageId])
}
